%
% FH Technikum Wien
% !TEX encoding = UTF-8 Unicode
%
% Erstellung von Master- und Bachelorarbeiten an der FH Technikum Wien mit Hilfe von LaTeX und der Klasse TWBOOK
%
% Um ein eigenes Dokument zu erstellen, müssen Sie folgendes ergänzen:
% 1) Mit \documentclass[..] einstellen: Master- oder Bachelorarbeit, Studiengang und Sprache
% 2) Mit \newcommand{\FHTWCitationType}.. Zitierstandard festlegen (wird in der Regel vom Studiengang vorgegeben - bitte erfragen)
% 3) Deckblatt, Kurzfassung, etc. ausfüllen
% 4) und die Arbeit schreiben (die verwendeten Literaturquellen in Literatur.bib eintragen)
%
% Getestet mit TeXstudio mit Zeichenkodierung ISO-8859-1 (=ansinew/latin1) und MikTex unter Windows
% Zu beachten ist, dass die Kodierung der Datei mit der Kodierung des paketes inputenc zusammen passt!
% Die Kodierung der Datei twbook.cls MUSS ANSI betragen!
% Bei der Verwendung von UTF8 muss dnicht nur die Kodierung des Dokuments auf UTF8 gestellt sein, sondern auch die des BibTex-Files!
%
% Bugreports und Feedback bitte per E-Mail an latex@technikum-wien.at
%
% Versionen
% *) V0.7: 9.1.2015, RO: Modeline angepasst und verschoben
% *) V0.6: 10.10.2014, RO: Weitere Anpassung an die UK
% *) V0.5: 8.8.2014, WK: Literaturquellen überarbeitet und angepasst
% *) V0.4: 4.8.2014, WK: Initalversion in SVN eingespielt
%
\documentclass[BMR,Bachelor,ngerman]{twbook}%\documentclass[Bachelor,BMR,german]{twbook}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{color}
\usepackage{graphicx,array}
\usepackage{colortbl} 
\usepackage{epic,eepic}
\usepackage{amsgen,amsfonts,amssymb,amsbsy,amsmath,amstext}
\usepackage[official]{eurosym}

%
% Bitte in der folgenden Zeile den Zitierstandard festlegen
\newcommand{\FHTWCitationType}{HARVARD} % IEEE oder HARVARD möglich - wenn Sie zwischen IEEE und HARVARD wechseln, bitte die temorären Dateien (aux, bbl, ...) löschen
%
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{\usepackage{harvard}}{\usepackage{bibgerm}}

% Definition Code-Listings Formatierung:
\usepackage[final]{listings}
\lstset{captionpos=b, numberbychapter=false,caption=\lstname,frame=single, numbers=left, stepnumber=1, numbersep=2pt, xleftmargin=15pt, framexleftmargin=15pt, numberstyle=\tiny, tabsize=3, columns=fixed, basicstyle={\fontfamily{pcr}\selectfont\footnotesize}, keywordstyle=\bfseries, commentstyle={\color[gray]{0.33}\itshape}, stringstyle=\color[gray]{0.25}, breaklines, breakatwhitespace, breakautoindent}
\lstloadlanguages{[ANSI]C, C++, [gnu]make, gnuplot, Matlab, Python}

%Formatieren des Quellcodeverzeichnisses
\makeatletter
% Setzen der Bezeichnungen für das Quellcodeverzeichnis/Abkürzungsverzeichnis in Abhängigkeit von der eingestellten Sprache
\providecommand\listacroname{}
\@ifclasswith{twbook}{english}
{%
    \renewcommand\lstlistingname{Code}
    \renewcommand\lstlistlistingname{List of Code}
    \renewcommand\listacroname{List of Abbreviations}
}{%
    \renewcommand\lstlistingname{Quellcode}
    \renewcommand\lstlistlistingname{Quellcodeverzeichnis}
    \renewcommand\listacroname{Abkürzungsverzeichnis}
}
% Wenn die Option listof=entryprefix gewählt wurde, Definition des Entyprefixes für das Quellcodeverzeichnis. Definition des Macros listoflolentryname analog zu listoflofentryname und listoflotentryname der KOMA-Klasse
\@ifclasswith{scrbook}{listof=entryprefix}
{%
    \newcommand\listoflolentryname\lstlistingname
}{%
}
\makeatother
\newcommand{\listofcode}{\phantomsection\lstlistoflistings}

% Die nachfolgenden Pakete stellen sonst nicht benötigte Features zur Verfügung
\usepackage{blindtext}

%
% Einträge für Deckblatt, Kurzfassung, etc.
%
\title{IoT Anwendung für einen Candy Grabber}
\author{Mag.art. Daniela Riedl}
\studentnumber{1510330062}
%\author{Titel Vorname Name, Titel\and{}Titel Vorname Name, Titel}
%\studentnumber{XXXXXXXXXXXXXXX\and{}XXXXXXXXXXXXXXX}
%\supervisor{Richard Otrebski, MSc}
\supervisor[Begutachter]{Richard Otrebski, MSc}
%\supervisor[Begutachterin]{Titel Vorname Name, Titel}
%\secondsupervisor{Titel Vorname Name, Titel}
%\secondsupervisor[Begutachter]{Titel Vorname Name, Titel}
%\secondsupervisor[Begutachterinnen]{Titel Vorname Name, Titel}
\place{Wien}
\kurzfassung{
%Viele Zukunftsvisionen wie Smart Factories und selbstverwaltende Verkehrsnetze basieren auf Dingen, die in der Lage sind, ihre Umgebung wahrzunehmen, die gesammelten Daten zu verarbeiten und diese mit anderen Geräten und Nutzern zu kommunizieren. 
Die Fähigkeit von Dingen zu kommunizieren und ihr Zusammenschluss zu interagierenden Netzwerken wird unter dem Begriff Internet of Things (IoT) zusammengefasst. Täglich werden neue Anwendungsgebiete für das IoT erschlossen und die Anzahl der Dinge im Internet übersteigt bereits die Anzahl der Weltbevölkerung.
%Eine unübersichtliche Anzahl an Softwareplattformen und eingesetzten Kommunikationsprotokollen
Ein wichtiger Katalysator für die Entwicklung von IoT ist die rasche Erstellung von Prototypen um neue Anwendungsfelder zu evaluieren und Ideen auszureifen. Dies gestaltet sich aufgrund der inhärent multidisziplinären Eigenschaften von IoT-Anwendungen und dem derzeitigen Mangel an allgemeinen Architekturstandards als komplexe Aufgabe.
%Eine große Schwierigkeit liegt derzeit in einem Mangel an standardisierten Entwicklungsmethoden und Architekturmodellen für IoT-Anwendungen.
 Um EntwicklerInnen den Einstieg in das IoT zu erleichtern, sind ausgereifte Entwicklungsmethoden zur Prototypen-Erstellung erforderlich.
In dieser Arbeit wurde der Prototyp einer kostengünstigen IoT-Anwendung für einen Spielzeug Candy Grabber entworfen und implementiert. Die Entwicklung des Systems wurde in einem iterativen Prozess mithilfe von Methoden aus dem Prototyping innerhalb eines Monats Entwicklungszeit umgesetzt. Die Auswahl der Toolchain erfolgte in einem fortschreitenden Prozess auf Basis von Recherche und Versuchsaufbauten auf einem Raspberry Pi3.
Als Ergebnis der Experimente wurde eine OPC-Unified Architecture (OPC UA) ausgewählt und mithilfe von \emph{Python-opcua} implementiert. Die Benutzerschnittstelle wurde mit Node-RED, einem auf Node-JS basierenden Tool zur Datenflussprogrammierung, verwirklicht. Durch die eingesetzten Prototyping Methoden wie der teilweisen Implementierung kritischer Systemkomponenten während der Planungsphase konnte ein funktionierender Prototyp innerhalb der vorgegebenen Entwicklungszeit erstellt werden.}
%Zu diesem Zweck wurde eine Auswahl von Prototyping-Tools und IoT-Protokollen basierend auf Versuchsaufbauten auf einem Raspberry Pi3 verglichen.
\schlagworte{Internet der Dinge, IoT, Rapid-Prototyping, Node-RED, Raspberry Pi}
\outline{
A lot of visions of the future like smart factories and self managing traffic grids are based on things that are able to perceive their environment, process the collected data and communicate it with other devices and users. The ability of things to communicate and their integration into intelligent, interacting networks is summarized under the term \acf{IOT}. New areas of application for the \ac{IOT} are being opened up on a daily basis and the number of things on the Internet already exceeds the number of the world's population. An important catalyst for the rapid development of \ac{IOT} is the ability to quickly create prototypes to assess the application of new ideas. This is still a complex task, due to the inherently multidisciplinary nature of \ac{IOT} applications. Another difficulty lies in the current lack of standardized development methods and architectural models for \ac{IOT} applications. To help developers get started with the \ac{IOT}, well defined development methods are needed as well as simple and inexpensive prototyping tools. In this thesis, the prototype of a cost-effective IoT application for a toy Candy Grabber is designed and implemented. To this end, a selection of prototyping tools and \ac{IOT} protocols have been compared based on experimental setups on a Raspberry Pi3. As a result to these experiments, an \ac{OPC UA} server-client architecture was chosen and has been implemented with the open license library \emph{freeopcua}. For the client, as well as the graphical user interface, the data flow programming tool Node-RED was utilized. The use of prototyping methods during the development process, such as experimentation and the partial implementation of critical parts, contributed significantly to the successful creation of a working prototype within one month of development time.}
%To that end, the respective things need to be able to perceive their environment, process the collected data and communicate it with other devices and users. To keep up with the rapidly growing market, simple and inexpensive tools are needed to help developers get started with the \ac{IOT}.   
\keywords{Internet of Things, IoT, Rapid-Prototyping, Node-RED, Raspberry Pi}
\acknowledgements{Bedankung}

\begin{document}

%Festlegungen für den HARVARD-Zitierstandard
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{
\bibliographystyle{Harvard_FHTW_MR}%Zitierstandard FH Technikum Wien, Studiengang Mechatronik/Robotik, Version 1.2e
\citationstyle{dcu}%Correct citation-style (Harvardand, ";" between citations, "," between author and year)
\citationmode{abbr}%use "et al." with first citation
\iflanguage{ngerman}{
    %Deutsch Neue Rechtschreibung
    \newcommand{\citepic}[1]{(Quelle: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Quelle: \protect\cite{#1}, S. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Quelle: modifiziert "ubernommen aus \protect\cite{#1}, S. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Verf{\"u}gbar unter:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Verf{\"u}gbar bei:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Zugang am}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{S.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{S.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{K.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{ausschließlich Abstract}
    \newcommand{\edition}{. Auflage}%Angabe der Auflage
}{
\iflanguage{german}{
    %Deutsch
    \newcommand{\citepic}[1]{(Quelle: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Quelle: \protect\cite{#1}, S. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Quelle: modifiziert "ubernommen aus \protect\cite{#1}, S. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand\citet{\citeasnoun}
    \newcommand\citep{\cite}
   % \newcommand{\citet}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Verf{\"u}gbar unter:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Verf{\"u}gbar bei:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Zugang am}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{S.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{S.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{K.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{ausschließlich Abstract}
    \newcommand{\edition}{. Auflage}%Angabe der Auflage
}}}

\maketitle

%
%
%-------------------------------------------------------------EINLEITUNG
\chapter{Einleitung}
%\acf{IOT}: Kommunikation zwischen Dingen über das Internet.\\ Wichtige Rolle in Cyber physical systems für Industrie 4.0\\ 
Eine Vision für die Industrie der Zukunft ist die Entwicklung intelligenter, vernetzter Fabriken, in denen alle Abläufe vom Bestellvorgang über die Produktion bis hin zur Auslieferung vollautomatisiert ablaufen. Das Produkt selbst wird zu einem kommunizierendem Objekt, dessen Produktionsstatus zu jedem Zeitpunkt abgefragt werden kann. Auch über die Produktionsgrenzen hinaus sollen die Dinge mit anderen Dingen und Nutzern kommunizieren und schließlich zu großflächigen, interagierenden Systemen vernetzt werden. Zusammengefasst werden die kommunizierenden Dinge und deren Vernetzung als \acf{IOT} bezeichnet.\\\newline
% Real world problem: Prototyping im IOT: Interaktive Echtzeitanwendung, kurze Entwicklungszeit, Spatenübergreifende Entwicklungsss
Eine \ac{IOT} Anwendung muss die Kommunikation aller beteiligten Geräte ermöglichen, sollte energieeffizient aufgebaut sein und Sicherheit vor Angriffen von außen gewährleisten. In interaktiven \ac{IOT} Anwendungen und echtzeit-kritischen Cyber-Physischen-Systemen werden geringe Latenzen und eine rasche Reaktionszeit vorausgesetzt. Skalierbarkeit ist ein weiterer wesentlicher Faktor in der Planung von \ac{IOT} Systemen, da die rasch wachsenden Netzwerke die nötigen Kapazitäten für Neuzugänge bereitstellen müssen. Bis 2020 werden laut \citeasnoun{gubbi2013internet} geschätzte 24 Mia. Dinge das Internet bevölkern. Um mit dem rasant wachsenden Markt mitzuhalten sind einfache und kostengünstige Werkzeuge notwendig um EntwicklerInnen den Einstieg in das \ac{IOT} zu erleichtern. Ein wesentlicher Katalysator für die Entwicklung von \ac{IOT} Anwendungen ist das Erstellen von Prototypen um die Einsatzfelder neuer Ideen zu evaluieren und die Interoperabilität der einzelnen Komponenten eines Systems von Beginn an zu prüfen.\\\newline
%
Rasches Prototyping gestaltet sich aufgrund der inhärent spartenübergreifenden Identität von \ac{IOT} Anwendungen und den oben genannten umfassenden Anforderungen an diese als komplexe Aufgabe. Eine große Schwierigkeit in der Entwicklung von \ac{IOT} Anwendungen ist derzeit laut \citeasnoun{pramudianto2013model} der Mangel an standardisierten Entwicklungsmethoden und Architekturmodellen. Durch die Vielzahl an angebotenen Protokollen und Softwareplattformen wird die Auswahl einer passenden Toolchain noch erschwert.\\\newline
%
Aufgabe dieser Arbeit ist es, den Prototyp einer kostengünstigen \ac{IOT} Anwendung für einen Spielzeug Süssigkeitenautomat (Candy Grabber) zu planen und umzusetzen. Als Grundlage für die Anwendung wird eine Auswahl von Werkzeugen und Protokollen vorgestellt, die im Hinblick auf \ac{IOT} Anwendungen und Rapid Prototyping entwickelt wurden. Anhand von Versuchsaufbauten soll eine Toolchain ausgewählt und durch die Implementierung der Anwendung evaluiert werden.

%Neben den gängigen Internet-Protokollen gibt es Protokolle, die speziell für den Einsatz von Geräten mit geringer Rechenleistung oder für Netzwerke mit niedriger Übertragungsrate entwickelt wurden. Des Weiteren werden Industrieprotokolle in sicherheitsrelevanten Echtzeit-Systemen, sogenannten \emph{Cyber-Physischen Systemen} (Cyber Physical Systems) (CPS) eingesetzt.
%Um mit dem rasant wachsenden Markt mitzuhalten sind einfache und kostengünstige Werkzeuge zur Entwicklung von \ac{IOT} Systemen notwendig um EntwicklerInnen einen raschen Einstieg in das \ac{IOT} zu ermöglichen.
%Forschungsfragen:\\Ausblick auf Thesis
%Die Auswahl der Protokolle zur Umsetzung eines \ac{IOT} Systems ist abhängig von den jeweiligen Systemvoraussetzungen und muss individuell für jedes System angepasst werden. 
%wird durch die Erstellung von Prototyping Versuchsaufbauten mit den vorgestellten Tools getestet und verglichen. Eine \ac{IOT} Anwendung zur Fernsteuerung eines Candy Grabbers soll implementiert werden. Hierfür soll aufbauend auf den vorangegangenen Tests eine passende Toolchain ausgewählt, und diese anhand der Implementierung evaluiert werden. Den unterschiedlichen Strömungen des \ac{IOT} soll hierbei Rechnung getragen werden. Weiters werden Entwicklertools zur Erstellung von \ac{IOT} Prototypen vorgestellt.
\clearpage
%Nachdem das Internet die globale Vernetzung zwischen Personen revolutioniert hat, ist laut \citeasnoun{gubbi2013internet} der nächste Schritt in der Entwicklung des Internets die Interaktion mit realen Objekten und deren Vernetzung zu intelligenten Systemen. Es existiert bereits eine Vielzahl von Anwendungsbereichen für das \ac{IOT} und sie reichen vom privaten und häuslichen Bereich bis hin zu vernetzten Städten. 
%Jeder Anwendungsbereich stellt unterschiedliche Anforderungen an die Entwicklung von \ac{IOT} Anwendungen und birgt andere Herausforderungen. 
%Real world problem:\\%Gesamtherausforderung: viele neue Dinge: Neue Protokolle notwendig, Energieverbrauch effizient gestalten, Sicherheit der IoT systeme gewährleisten, Skalierbarkeit für die schnell wachsenden Netzwerklösungen.
% Real world problem: Prototyping im IOT: Interaktive Echtzeitanwendung, kurze Entwicklungszeit, Spatenübergreifende Entwicklung
%Weiters ist eine effiziente Energieversorgung für mobile Geräte und großflächige Sensor-Netze \acp{WSN} zu gewährleisten um die ökologischen Auswirkungen des \ac{IOT} minimal zu halten. \ac{IOT} Systeme vor Hacker Angriffen und Malware Attacken zu schützen ist besonders im \ac{IIOT} und \ac{CIOT} eine große Herausforderung.
%------------------------------------AUFGABENSTELLUNG
\chapter{Ferngesteuerter Süssigkeitenautomat}
%BILD Candy Grabber
\section{Anforderungen}
Für einen Candy Grabber Süssigkeitenautomat ist eine \ac{IOT} Anwendung zu erstellen. Diese soll die Möglichkeit bieten, den Candy Grabber per Joystick oder per Fernbedienung von einem Computer oder Mobiltelefon zu steuern. Des Weiteren soll es möglich sein, eigene Steuerungsprogramme hochzuladen und zu testen um den Candy Grabber in weiterer Folge als Lernplattform für \ac{IOT} Projekte nutzen zu können.
\begin{figure}[H]
\centering
\includegraphics[width=0.45\linewidth]{./PICs/CandyGrabber.png}
\caption{Fernzusteuernder Candy Grabber}
\end{figure}

\section{Aufgabenstellung}
%\section{Vorgehensweise}
Zur Fernsteuerung des Candy Grabbers müssen Sensordaten sowie Steuersignale erfasst und übertragen werden. Weiters ist es notwendig die Bewegungen des Candy Grabbers beobachten zu können um eine erfolgreiche Steuerung zu ermöglichen. Hierfür sollen die Aufnahmen einer Kamera live über Videostream übertragen werden.
\subsubsection{Hardware}
Die vorhandene Hardware des Candy Grabbers soll möglichst komplett erhalten bleiben um das Budget gering zu halten und die Kompatibilität der Komponenten zu gewährleisten. Zu diesem Zweck wird eine Analyse der Hardware vorgenommen und eine Sensor/Aktorliste erstellt. Des Weiteren soll ein Schaltplan zum Anschluss der Hardware über die Hardware-Schnittstellen (\acp{GPIO}) des ausgewählten \ac{IOT} Geräts erstellt werden. Besonderes Augenmerk ist auf eine gründliche Dokumentation zu legen um die Einarbeitungszeit für nachfolgende Projekte gering zu halten.
\subsubsection{Software}
%Python: He means that Python runs on Windows, Linux, and Mac without issues. C++ would have to be compiled for each OS. Having to compile often makes prototyping slow and less effective.
Die Software soll modular und in einer objektorientierten Programmiersprache implementiert werden. Zur Steuerung des Gerätes soll ein Objekt der Klasse \emph{CandyGrabber} erstellt werden. Dieses Objekt soll den Zugriff auf seine Eigenschaften und Funktionalität über einen Server erlauben und über eine Mensch-Maschinen Schnittstelle (\ac{HMI}) gesteuert werden können. Laut Vorgabe soll dies einerseits über das Bedien-Panel am Gerät und andererseits über eine grafische Oberfläche von der Ferne möglich sein.
%Tabelle Ziele
\begin{table}[H]
\caption{Ziele}
\centering
\begin{tabular}{| p{0.4\textwidth}| p{0.6\textwidth} |}\hline
\rowcolor[gray]{0.9}Ziele & Geplante Umsetzung \\\hline
Funktionalität gewährleisten & Gründliche Analyse der Hardware, Softwaretests, Erstellung von Versuchsaufbauten\\\hline
Gründliche Dokumentation & Erstellung von UML Diagrammen und Schalt- bzw. Kabelplänen sowie Versionierung der Software\\\hline
Modulare Software & Aufteilung des Candy Grabbers in Module, Einsatz von Design Patterns, Hardware Abstraktion \\\hline
Fernsteuerung ermöglichen & Einrichten eines Videostreams, Erstellen einer Webapplikation \\\hline
Eigene Steuerprogramme aufspielbar & Erstellung eines Objekts, Definition von Methoden und Eigenschaften, über Interface zugänglich\\\hline
Präsentation & Erstellung eines Videos, ansprechendes Design der HMI und des Candy Grabber Aufbaus, Spieluntermalung durch das Abspielen von Musikdateien und Tönen\\\hline
%Sicherheit (Security) gewährleisten & Identifikation über Username und Passwort erforderlich\\\hline
\end{tabular}
\end{table}
Besonderes Augenmerk ist auf die Auswahl der Kommunikationsprotokolle und Prototyping Werkzeuge, sowie auf das Design der Systemarchitektur zu legen um die geforderten Eigenschaften einer \ac{IOT} Anwendung umsetzen zu können. Diese Eigenschaften und Grundlegendes zum Aufbau von \ac{IOT} Systemen werden im folgendem Kapitel näher erläutert.
%%Aufgaben
%\begin{table}[!htbp]
%\caption{Vorgehen und Aufgaben}
%\centering
%\begin{tabular}{| p{0.33\linewidth}| p{0.33\linewidth} | p{0.33\linewidth}|}\hline
%\rowcolor[gray]{0.8}Analyse und Planung & &\\\hline
%Auswahl eines \ac{IOT} Geräts & Auswahl zusätzlich benötigter Hardware & Gründliche Dokumentation\\\hline
%Analyse der Original Hardware & Erstellung Sensor/Aktor Liste \newline Entwurf Schaltplan & Anschluss an Rechner\\\hline
%\rowcolor[gray]{0.8}Systementwurf &&\\\hline
%Hardware Abstraktion und Schnittstellen & Systementwurf \newline Klassendiagramm erstellen & Ablauf planen \newline Ablaufdiagramm erstellen\\\hline
%Schnittstellen und Systemgrenzen definieren & Methoden und Properties \newline definieren & Steuerungsprogramm erstellen\\\hline
%\rowcolor[gray]{0.8}Systementwicklung &&\\\hline
%Versuchsaufbauten erstellen & Auswahl der Toolchain &  Aufsetzen eines Servers \\\hline
%Kommunikation mit Client & Webapplikation erstellen & Videostream einrichten\\\hline
%%\rowcolor[gray]{0.8}Systemintegration &&\\\hline


%\end{tabular}
%\end{table}
\clearpage

%------------------------------------------------------------STAND DER TECHNIK
\chapter{Stand der Technik}
%Aufbau Eigenschaften
\ac{IOT} Systeme besitzen nach \citeasnoun{wolf2016architecture} die Fähigkeit Veränderungen bestimmter Parameter durch Sensoren in der physischen Welt wahrzunehmen, die notwendige Rechenleistung um eingehende Datenpakete zu verarbeiten und die Möglichkeit Reaktionen in der physischen Welt durch Aktoren zu evozieren. Um diese Eigenschaften zu bilden bestehen \ac{IOT} Systeme laut \citeasnoun{gubbi2013internet} aus den drei Grundbausteinen \emph{Hardware}, \emph{Middleware}  und  \emph{Präsentation}. Die \emph{Hardware} dient zur Interaktion mit Objekten und der Umwelt, die \emph{Middleware} ermöglicht die Speicherung und Auswertung von Daten und die \emph{Präsentation} visualisiert und interpretiert die gewonnenen Daten. Wie diese Grundbausteine in einem \ac{IOT} System organisiert werden ist abhängig von der jeweiligen Anwendung. Für die Umsetzung einer \ac{IOT} Anwendung gibt es viele mögliche, vorgeschlagene Architekturmodelle und Visionen.
%-----------------------------------
\section{Architekturmodelle}
In \citeasnoun{wu2010architecture} sind die gängigen \ac{IOT}-Schichtmodelle beschrieben, die bis dato zur Orientierung für \ac{IOT} Architekturen verwendet werden. Das einfachste ist das 3-Ebenen-Modell, bestehend aus einer Wahrnehmungsebene (\emph{Perception layer}), einer Netzwerkebene (\emph{Network-} oder \emph{Transport layer}) und einer Anwendungsebene (\emph{Application layer}).
%
\citeasnoun{wu2010architecture} schlugen eine Erweiterung dieses Modells vor um das Internet der Dinge zu organisieren und kontrollierbar zu gestalten. Aus dem \ac{OSI} Modell und dem \ac{TCP} Modell wurde eine neue \ac{IOT} Architektur abgeleitet und das 3-Ebenen-Modell um eine Bearbeitungsebene (\emph{Processing layer}) und eine Managementebene (\emph{Business layer}) erweitert.
%figure 5 layer
%\begin{figure}[H]
%\centering
%\includegraphics[width=0.35\linewidth]{PICs/5Layers}
%\caption{5-Ebenen-Modell. (Quelle: \protect\citeasnoun{wu2010architecture}, S. 486)}
%\label{5layers}
%\end{figure}
%
%
Mittlerweile existieren zahlreiche Vorschläge von Architekturmodellen für \ac{IOT} Systeme. Unterschiedliche \ac{IOT} Anwendungen erfordern unterschiedliche Schwerpunkte und bisher hat sich noch kein allgemeiner Standard aus den vorgeschlagenen Architekturmodellen herauskristallisiert. Welches Modell zur Systemmodellierung herangezogen wird muss für jede Anwendung gesondert entschieden werden. Abbildung \ref{fig:layer} zeigt einige mögliche \ac{IOT} Architekturmodelle: das 3-Ebenen-Modell, ein Middleware orientiertes Modell, ein auf \ac{SOA} basierendes Modell und eine Variante des 5-Ebenen-Modells von \citeasnoun{wu2010architecture}. In Tabelle \ref{tab:layers} sind die Aufgaben der jeweiligen Schichten übersichtsweise dargestellt.
%figure other architectures
\begin{figure}[!htbp]
\centering
\includegraphics[width=0.8\textwidth]{PICs/iotArchitecture}
\caption{Die \ac{IOT} Architektur. (a) 3-Ebenen-Modell. (b) Middleware orientiert. (c) SOA basierend. (d) 5-Ebenen-Modell. (Quelle: \protect\cite{alfuqaha2015survey}, S. 2349)}\label{fig:layer}
\end{figure}
%Tabelle Aufgaben der Ebenen im IOT
\begin{table}[H]
\caption{Aufgaben der Ebenen im \ac{IOT}}
\label{tab:layers}
\centering
\begin{tabular}{| p{0.2\textwidth}| p{0.8\textwidth} |}\hline
\rowcolor[gray]{0.9}Ebene & Aufgabe \\\hline
\emph{Perception Layer} & Auch \emph{Device Layer} oder \emph{Physical Layer} genannt. Hier werden objektspezifische Sensordaten und Informationen identifiziert und gesammelt. \cite{khan2012future}.\\\hline
%Daten werden zum Zweck der sicheren Übertragung an den \emph{Transport Layer} weitergeleitet 
\emph{Transport Layer} & Auch \emph{Network Layer} genannt. Dieser gewährleistet die sichere Übertragung der gewonnenen Daten aus dem \emph{Perception Layer} durch ein Übertragungsmedium (kabelgebunden oder kabellos) zum nächsten Layer in dem die Daten verarbeitet werden \cite{khan2012future}.\\\hline
%
\emph{Process Layer} & Diese Ebene wurde zur Speicherung, Analyse und Verarbeitung der Daten aus dem \emph{Transport Layer} extrahiert.\\\hline
%
\emph{Middleware Layer} & Auch \emph{Service Management Layer} genannt, ermöglicht es Entwicklern  unterschiedliche Objekte in ihre Anwendungen zu integrieren, ohne die spezifische Hardware-Anbindung jedes Objekts berücksichtigen zu müssen. Dienste (\emph{Services}) können durch die Nutzung von Adressen und Namen an die, die Dienste anfordernden Parteien übermittelt werden. Weiters werden hier wie auch im \emph{Processing Layer} Daten empfangen und verarbeitet \cite{alfuqaha2015survey}.\\\hline
%
\emph{Application Layer} & Hier findet die Kontextualisierung, Aufbereitung und Visualisierung der Daten statt. Im 3-Ebenen Modell erfüllt der \emph{Application Layer} auch die Aufgaben des \emph{Process Layers}.\\\hline
%
\emph{Business Layer} & Hier werden die Anwendungen aus dem \emph{Application Layer} organisiert und im Sinne von Langzeitentwicklungen evaluiert. Hierdurch werden Entscheidungsprozesse bezüglich des Einsatzes von Ressourcen und Investments unterstützt.\\\hline
\end{tabular}
\end{table}
\citeasnoun{ning2011future} schlugen ein weiteres Architekturmodell vor, welches von den menschlichen Fähigkeiten Eindrücke zu verarbeiten, Entscheidungen zu treffen und zu reagieren bzw. agieren inspiriert ist. Dieses besteht aus einem \emph{Gehirn}, dem \emph{Rückenmark} und einem \emph{Nerven-Netzwerk}. Das Gehirn entspricht in diesem Modell der Datenzentrale und ist zuständig für die Datenverarbeitung und das Datenmanagement. Das Rückenmark agiert als verteiltes Netzwerk von Daten-verarbeitenden Knoten und ist für den Transport der Daten zuständig. Ein Netzwerk von Nerven nimmt Veränderungen in der Umgebung wahr und sammelt Informationen, es entspricht also einem Netz aus Sensoren.
%Cloud und Fog Architektur
\section{Systemarchitekturen}
Die meisten \ac{IOT} Systeme sind bisher Cloud-zentriert aufgebaut, das heißt die Daten werden in Cloud Computern gesammelt und verarbeitet. Die Cloud stellt hier die zentrale, verarbeitende Schicht zwischen der darüber liegenden Applikationsschicht und den darunter liegenden vernetzten Objekten dar. Ein weiterer Trend geht derzeit in Richtung einer alternativen Systemarchitektur, dem \emph{Fog Computing}. Hierbei werden die gesammelten Daten bereits in den Sensoren selbst oder in Netzwerks-Zugangsknoten (im boden-nahen Nebel) aufbereitet bevor sie zur weiteren Auswertung in die Cloud gelangen \cite{sethi2017internet}.\\\newline
%Vertikal und Horizontale Architektur
Derzeit werden \ac{IOT} Architekturen weitgehend vertikal integriert und arbeiten unabhängig voneinander. Wenn ein neues Gerät zu einem Netzwerk hinzugefügt werden soll muss dieses vollständig integriert werden, das heißt über alle Schichten hinweg eingebettet werden. \citeasnoun{wolf2016architecture} sehen den Grund für diese vertikale Integrierung in den vielfältigen, individuell angepassten \ac{IOT} Architekturen. Sie schlagen eine horizontal integrierte \ac{IOT} Architektur vor um die Einbindung neuer Objekte zu vereinfachen. \ac{IIOT} Systeme würden allerdings von dieser Architektur nicht profitieren, da in diesen meist die Abgrenzung zu anderen Systemen aus Sicherheitsgründen erfolgen muss und eine individuell angepasste Architektur erwünscht ist.\\\newline
Eine \ac{IOT} Anwendung kann laut \citeasnoun{atzori2010internet} folgenden Paradigmen folgend implementiert werden: internet-orientiert, ding-orientiert oder semantisch-orientiert. Die \ac{IOT} Anwendung muss jedoch immer eine Kreuzung dieser Paradigmen darstellen damit sie laut \citeasnoun{gubbi2013internet} ihre Funktionalität entfalten kann. In diesen unterschiedlichen Visionen sieht \citeasnoun{pramudianto2013model} den Grund für den derzeitigen Mangel an standardisierten Entwicklungsmethoden und Architekturmodellen, der die Entwicklung von \ac{IOT} Anwendungen erschwert.\clearpage
%Im kommerziellen \ac{IOT} wird unterschieden zwischen einem industriellem Internet der Dinge (\ac{IIOT}) und einem gewerblichen Internet der Dinge (\ac{CIOT}) \cite{marcon2017communication}.

%\\\newline\citeasnoun{pramudianto2013model} schlagen eine von der technischen Umsetzung losgelöste, modellgetriebene Entwicklung für \ac{IOT} Anwendungen vor um deren Konzept unabhängig von ihrer konkreten Umsetzung weiterentwickeln zu können.{\color{red} Eventuell zwei Hauptkonzepte herausgreifen und kurz erläutern: IEEE und IETF z.B und Tabelle von Protokollen als Bild einfügen}
%Im \ac{IOT} verschwimmen die Grenzen zwischen Informationstechnologie IT und operativer Technologie (Operational Technology) OT.
%--------------------------------------------------Protokolle
\section{Standards und Protokolle für das \ac{IOT}}
Um die Entwicklung von \ac{IOT} Applikationen voranzutreiben und die Kommunikation zwischen diesen zu fördern arbeiten verschiedene Entwicklerteams an der Standardisierung von Entwicklungsmethoden und Architekturmodellen. Das \ac{W3C}, die \ac{IETF}, das \ac{IEEE} und das \ac{ETSI} erarbeiten Standards für \ac{IOT} Architekturmodelle und Lösungen zu deren Implementierung \cite{alfuqaha2015survey}. Als Standard Protokolle für das \ac{IOT} werden meist das \acf{CoAP} und das \acf{MQTT} Protokoll genannt. Abbildung \ref{fig:protocols} zeigt eine Auswahl der wichtigsten, im \ac{IOT} eingesetzten Kommunikationsprotokolle. Auf die Protokolle \ac{MQTT} und \ac{CoAP} soll in weiterer Folge näher eingegangen werden. Weiters wird das Industrieprotokoll \ac{OPC UA} vorgestellt, welches von der OPC Foundation entwickelt wurde um die plattformunabhängige Interoperabilität von Maschinen zu gewährleisten.
%figure protocols
\begin{figure}[!htbp]
\centering
\includegraphics[width=0.8\textwidth]{PICs/protocols}
\caption{\ac{IOT} Kommunikationsprotokolle auf das \ac{OSI} Modell gemapt (Quelle: \protect\cite{nathali2018iot}, S. 211)}\label{fig:protocols}
\end{figure}
%
%MQTT
\subsection{\acf{MQTT}}
\ac{MQTT} wurde von Andy Stanford-Clark (IBM) und Arlen Nipper (Eurotech) 1999 für die asynchrone Übertragung von Telemetriedaten über unzuverlässige Verbindungen mit schlechter Datenrate entwickelt. Es wurde 2013 als offener Standard von OASIS spezifiziert \cite{mqtt2018specs} und eignet sich speziell für Geräte mit beschränkten Ressourcen und Netzwerke mit niedrigen Datenraten oder unzuverlässiger Datenübertragung \cite{alfuqaha2015survey}. \ac{MQTT} besteht aus einem \emph{Broker}, sowie \emph{Publishern} und \emph{Subscribern}. Daten werden von \emph{Publishern} generiert, unter einem bestimmten \emph{Topic} veröffentlicht und können von Clients die an den Informationen interessiert sind über das jeweilige \emph{Topic} abonniert werden. Der \emph{Broker} informiert die \emph{Subscriber} über Veröffentlichungen in den abonnierten \emph{Topics} und leitet die Daten der \emph{Publisher} weiter. Die zwei wichtigsten Spezifikationen von \ac{MQTT} sind das über \ac{TCP} geroutete MQTT v3.1 sowie MQTT-SN, welches speziell für Sensornetzwerke erstellt wurde und über das \ac{UDP} transportiert wird \cite{alfuqaha2015survey}.
%
%CoAP
\subsection{\acf{CoAP}}
\ac{CoAP} ist ein Übertragungsprotokoll für \ac{IOT} Anwendungen, das von der \ac{IETF} Arbeitsgruppe CoRE (IETF Constrained RESTful Environments) entwickelt wurde und auf dem \ac{REST} Paradigma aufbaut. \ac{REST} ermöglicht es Clients und Servern, Webdienste wie das SOAP (Simple Object Access Protocol) Protokoll zu nutzen. Dabei werden Uni-Form Resource Identifiers (URIs) zur Identifizierung von Ressourcen genutzt und können mittels der \ac{HTTP}-Methoden \emph{get}, \emph{post}, \emph{put} und \emph{delete} abgerufen, veröffentlicht, eingefügt und gelöscht werden \cite{alfuqaha2015survey}. Die eingebundenen \ac{HTTP} Funktionalitäten wurden an \ac{IOT} Geräte mit beschränkten Ressourcen angepasst, daher verbraucht die Kommunikation über \ac{CoAP} laut \citeasnoun{sutaria2013making} 42\% weniger Strom als eine vergleichbare Kommunikation über \ac{HTTP}.
%
%OPC UA
\subsection{\acf{OPC UA}}
%Ursprünglich für die Kommunikation innerhalb eines industriellen Umfelds geplant, eignet sich \ac{OPC UA} aufgrund seiner hohen Skalierbarkeit und Sicherheit auch für den Einsatz in kommerziellen \ac{IOT} Anwendungen. The purpose of the OPC Unified Architecture was to enable a platform-independent interoperability standard for moving data/information between the factory floor and the enterprise. During the course of the development it was obvious that the OPC Unified Architecture was well positioned to expand beyond industrial auto- mation. OPC has expanded into areas of building automation, security, home automation, power generation, packaging, and petrochemicals. Because of the highly scalable architecture of OPC UA, it is also well-positioned for deployment in intelligent embedded devices.
\ac{OPC UA} \cite{opcua} ist ein service-orientiertes Industrie-Protokoll basierend auf einer Client-Server Struktur, welches in der Norm IEC-62541 standardisiert wurde {\color{red}Quelle Norm}. Die Daten werden objektorientiert modelliert und über den \ac{OPC UA} Server zur Verfügung gestellt. Das \ac{OPC UA} Framework beinhaltet den sogenannten \emph{Adressraum}, indem die Daten als Knoten vorhanden und durch Referenzen miteinander verbunden sind. Clients können diesen Adressraum über Internetdienste durchsuchen (\emph{browsen}) und auf exponierte Daten in diesem zugreifen. Dies kann über das \emph{Binary protocol} oder durch \ac{SOAP} basierende Internetdienste geschehen. Das \emph{Binary Protocol} ist ein Protokoll in Maschinensprache, das bei hohem Datendurchgang eingesetzt wird. \ac{SOAP} Dienste werden hauptsächlich eingesetzt um Probleme mit Firewalls zu umgehen. Der \ac{OPC UA} Standard bietet weiters Authentifizierung und Verschlüsselung in verschiedenen, wählbaren Sicherheitsstufen an \cite{palm2015open}. Aufgrund seiner hohen Skalierbarkeit ist der Einsatz von \ac{OPC UA} auch für \ac{IOT} Anwendungen außerhalb des industriellen Umfelds interessant. Die möglichen Implementierungen von \ac{OPC UA} sind in Abbildung \ref{fig:opcua} zusammengefasst und dem \ac{OSI} Modell gegenübergestellt.
%figure opcua-osi
\clearpage
\begin{figure}[!h]
\centering
\includegraphics[width=\textwidth]{PICs/osi_opcua.png}
\caption{\ac{OPC UA} auf das \ac{OSI} Modell gemapt (Quelle: \protect\cite{neumann2015opcua}, S. 2)}\label{fig:opcua}
\end{figure}
%
%source: http://www.drdobbs.com/web-development/soa-web-services-and-restful-systems/199902676
%\subsection{Service-oriented architecture (SOA)}
%is a paradigm where software components are created with concise interfaces, and each component performs a discrete set of related functions. With its well-defined interface and contract for usage, each component, provides a service to other software components. A web service is an example of an SOA with a well-defined set of implementation choices. In general, the technology choices are SOAP and the Web Service Definition Language (WSDL); both XML-based. WSDL describes the interface (the "contract"), while SOAP describes the data that is transferred. Because of the platform-neutral nature of XML, SOAP, and WSDL, Java is a popular choice for web-service implementation due to its OS-neutrality.
%OPC UA is a protocol for communication in industrial au- tomation, developed by the OPC Foundation and standardized in IEC-62541 [11].
%OPC UA is a protocol for communication in industrial automation, developed by the OPC Foundation and standardized in IEC-62541 [11].
%-------------------------------------------------- Prototyping
\section{Prototyping und Entwicklertools}
Ein Prototyp ist laut \citeasnoun{pomberger1992methoden} \emph{``\dots ein ausführbares Modell mit wesentlichen Eigenschaften des Zielsystems, das Grundlage für die Systemspezifikation ist und die Kommunikation zwischen Kunden und Entwickler unterstützt.''} Zur Erstellung eines Prototypen werden die Schritte Implementierung, Evaluierung und Adaptierung iterativ durchlaufen. Die Entwicklung eines Systems erfolgt nicht in klar voneinander abgetrennten Phasen innerhalb einer sequentiellen Folge sondern besteht aus ineinander übergehenden Phasen die wiederholt durchlaufen werden. Im sogenannten Archtekturprototyping wird ein Prototyp für die Systemarchitektur während der Entwurfsphase erstellt. Dieser bietet die Möglichkeit einer adäquaten Überprüfung des Systems vor der tatsächlichen Implementierung und kann vollständig sein, oder für einzelne, kritische Komponenten und Schnittstellen des Systems erstellt werden. Mithilfe dieser Technik lassen sich Risikos von Fehlentscheidungen sowie Kommunikationsprobleme mit KundInnen während der Spezifikation maßgeblich verringern. Weiters stellt diese Vorgehensweise ein Mittel zur Qualitätssicherung dar und bietet einen hohen Lerneffekt. Die Erstellung von Prototypen ist heutzutage gängige Praxis und kann über den Bau eines realen Produkts oder auch über Umsetzung einer Simulation erfolgen \cite{pomberger1992methoden}.
%\\\newline In the quality gate concept published by the VDMA, the development of a mechatronic system is split up into development stages. At the end of each stage its results are evaluated. The next stage is only commenced if all requirements of the previous stage are met with sufficient quality. Figure 3 depicts the development process of a product and its stages according to the quality gate concept. The three colored lines represent the three basic pillars of a mechatronic system, mechanical engineering, electronic engineering and software engineering (Bender et al., 2006).
%The production line is developed with an iterative approach to ensure compatibility between these disciplines at every stage. Due to this iterative approach structural changes in the template are still possible in the further development process of the production line. Therefore, this thesis documents the current state of development rather than the completed system.\\\newline
%
\\\newline
Um die Entwicklung von \ac{IOT} Prototypen zu vereinfachen existieren eine Auswahl an preiswerten Einplatinencomputern und Entwicklerboards für die Hardwareanbindung sowie eine Vielzahl von Softwareplattformen und Schnittstellen zur Anwendungsprogrammierung (\acp{API}).
\subsection{Entwicklerboards und Einplatinencomputer} 
Für die Realisierung des \emph{Physical Layers} werden für die Erstellung von Prototypen meist Mikrocontroller oder sogenannte Ein-Chip-Systeme (System-on-a-Chip (SoC)) herangezogen. Diese bieten Fähigkeiten zur Datenverarbeitung und Speicherung sowie Schnittstellen zur seriellen Datenübertragung und Netzwerkkommunikation. Mikrocontroller sind SoCs die über einen oder mehrere Prozessorkerne, Arbeitsspeicher (RAM) und nicht flüchtigen Speicher (EPROM) zur Speicherung von Programmen verfügen. Entwicklerboards sind Mikrocontroller, die über zusätzliche Schaltkreise zur einfacheren Programmierung und Hardwareanbindung verfügen. Über \acfp{GPIO} können Sensoren und Aktoren an den Mikrocontroller angeschlossen werden. Des Weiteren werden Datenbusse zur Verfügung gestellt über die eine serielle Kommunikation mit externen Geräten zum Beispiel über I2C (Inter Integrated Circuit) ermöglicht wird. Ein Beispiel für Entwicklerboards ist die offene Plattform Arduino (http://arduino.cc/en/Main/). Arduino verfügt über eine große Entwicklergemeinschaft die kompatible Werkzeuge und Entwicklerboards zur Erweiterung des Systems anbieten, zum Beispiel Arduino-UNO oder den Wi-Fi fähigen Mikrocontroller ESP8266-01.\\\newline
Einplatinencomputer (Single board computers (SBCs) erlauben den Anschluss externer Geräte wie Tastaturen und Bildschirme und bieten eine leistungsstärkere Alternative zu Entwicklerboards. Bekannte Vertreter von Einplatinencomputern sind der Raspberry Pi (RPi), BeagleBone Black oder Odroid {\color{red}(Quellen)}. Viele SBCs entsprechen Miniaturcomputern auf denen ein eingebettetes Betriebssystem läuft. Meistens die gestraffte Variante eines Open Source Linux Betriebssystems. Daher stehen für die Entwicklung von Anwendungen auf SBCs wesentlich mehr Entwicklungstools und Sprachoptionen zur Verfügung als auf Entwicklerboards. Die Kehrseite ist, dass SBCs meist größer, anfälliger für Softwareprobleme und komplexer aufzusetzen sind sowie mehr Energie benötigen. Einplatinencomputer können ähnlich wie Entwicklerboards durch externe Module oder Erweiterungsplatinen, sogenannten HATs im Fall von Raspberry Pi erweitert werden.
%
\subsection{Softwareplattformen}Oftmals erfordern interaktive \ac{IOT} Anwendungen die Integration von Online-Diensten sowie die Erfassung von Sensordaten und das Auslösen von Reaktionen annähernd in Echtzeit. Um die Entwicklung solcher Systeme zu vereinfachen wurden Tools und Plattformen entwickelt, die die Verknüpfung der einzelnen, datenverarbeitenden Komponenten unterstützen. Diese Plattformen übernehmen Dienste wie Konnektivität und Routing, z.B. \emph{Spacebrew} von \citeasnoun{spacebrew} oder die Verbindung von Services und Dingen über das \emph{Bedingung-Aktion} Paradigma, wie z.B. \emph{zapier} \cite{zapier}. Einige dieser Plattformen bauen auf dem Paradigma der Datenflussprogrammierung auf um die Flexibilität der Programme zu erhöhen und Anwenderfreundlichkeit zu bieten. Ein Beispiel hierfür ist Node-RED \cite{nodered}, ein Open Source Tool zur visuellen Programmierung und Laufzeitumgebung für Datenflussprogramme \cite{giang2014toward}.
\subsection{Node-RED}
%Visual Data Flow Programming Language (VDFPL)
%Node- RED is toolkit for developing data flows on devices and servers.
Node-RED ist ein Web-basiertes Tool zur Vernetzung von \acp{API} und netzwerkfähigen Geräten. Es baut auf dem \emph{Node.js} framework auf, welches eine asynchrone ereignisgesteuerte \emph{JavaScript} Laufzeitumgebung bietet um skalierbare Netzwerkanwendungen zu erstellen {\color{red}(Quelle: https://foundation.nodejs.org/about)}. Über einen Browser-basierten Flow-Editor können Datenflussprogramme, sogenannte Flows erstellt werden, die auf dem Node-RED Server zur Ausführung bereitgestellt werden. Flows bestehen aus einzelnen Knoten (Nodes), die über Kabel miteinander verbunden sind. Alle Nodes erben von der Node-Basisklasse und sind Unterklassen des \emph{Node.js} \emph{EventEmitters}. Bei der Instanziierung können Nodes externe Dienste abonnieren, auf Daten von einem Port warten oder mit der Verarbeitung von \ac{HTTP}-Anforderungen beginnen. Sobald Daten von einem Node über seinen Eingabe-Handler empfangen wurden, wird die send() Methode der Basisklasse aufgerufen die benannte Ereignisse über die \emph{emit()} Methode des \emph{EventEmitters} an nachgelagerte Nodes sendet. Die nachfolgenden Nodes verarbeiten die Daten, generieren weitere Ereignisse oder kommunizieren mit externen Diensten oder dem Betriebssystem. Es stehen Template-Nodes zu Verfügung, mit denen benutzerdefinierte Nodes erstellt werden können indem eine HTML-Datei hinzugefügt wird, um die Benutzeroberfläche im Browser zu implementieren, sowie eine JavaScript-Datei für die Datenverarbeitung oder Integration auf dem Server. Node-RED ist ein Open Source Projekt, das von IBM und einer großen Gemeinschaft von Benutzern vorangetrieben wird, die Nodes und Flows zum System beisteuern. \cite{giang2014toward}
% %Text representations of flows can be imported and exported between instances. When a node used in one instance of Node-RED is not available on another, a placeholder node is shown in the UI to indicate the user must install a missing node implementation before the flow can be deployed.
%Node-RED’s flows are expressed using JSON as shown in Figure 6. “wires” are not separate objects, but are arrays associated with each node connecting it to a downstream node. Configuration information that may be shared between nodes such as the twitter user name or MQTT topic is held in a configuration node without wires. flows on different tabs or pages are not separated in Node-RED, there is only one flow for the entire system.}
%
%{\color{red}Platform as a Service (PaaS) kostenpflichtige Plattformen}
%PaaS (Platform-as-a-Service) ist eine vollständige Entwicklungs- und Bereitstellungsumgebung in der Cloud, über die Sie Zugang zu den erforderlichen Ressourcen erhalten, um verschiedenste Lösungen bereitstellen zu können – von einfachen cloudbasierten Apps bis hin zu ausgereiften cloudfähigen Unternehmensanwendungen. Sie erwerben die erforderlichen Ressourcen basierend auf einem nutzungsabhängigen Zahlungsmodell von einem Clouddienstanbieter und greifen über eine sichere Internetverbindung darauf zu. {\color{red}https://azure.microsoft.com/de-de/overview/what-is-paas/} PaaS bietet Middleware, Entwicklungstools, BI-Dienste (Business Intelligence), Datenbank-Verwaltungssysteme und mehr. Mit PaaS lässt sich der gesamte Webanwendungs-Lebenszyklus unterstützen – vom Erstellen, Testen und Bereitstellen der Anwendungen bis hin zu deren Verwaltung und Aktualisierung.
%
%\subsection{\acp{API}}
\section{Open Source Projekte}
Open Source Projekte leisten einen wesentlichen Beitrag in der Entwicklung von Prototyping Werkzeugen und Protokollen für das \ac{IOT}. Laut \citeasnoun{palm2015open} können Open Source Projekte als Rückkopplungsschleifen (feedback loops) für Standardisierungsprozesse in der Softwareentwicklung gesehen werden. Weitere Vorteile liegen in der anwenderorientierten und transparenten Entwicklung von Open Source Software und der Möglichkeit, neue Technologien und deren Einsatzgebiete mit geringem finanziellen Risiko auszutesten. \citeasnoun{palm2015open} plädierten für eine Öffnung von Industriestandards um deren Entwicklung in Open Source Projekten voranzutreiben, zum Beispiel für die Erstellung einer Open Source Version von \ac{OPC UA}, die den Ansprüchen eines industriellen Umfelds genügt. %Inzwischen sind mehrere Open Source Implementierungen von \ac{opcua} im Umlauf, inklusive des von \citeasnoun{palm2015open} vorgeschlagenen
%Diese Open Source Version wurde unter dem Namen open62541 \cite{open62541} von der OPC Foundation 
Wichtige Open Source Beiträge zur \ac{IOT} Entwicklung stellen Linux, das Apache HTTP Server Projekt \cite{apache} und das \ac{MQTT} Protokoll dar \cite{mqtt} sowie die verschiedenen Open Source Implementierungen von \ac{OPC UA}, zum Beispiel die C++ Implementierung \emph{open62541} \cite{open62541} oder die Python Implementierung \emph{freeopcua}.
%\subsection{Raspbian: Linux für Raspberry Pi}
%\subsection{Apache}
%\subsection{RPi web cam Interface}
%\subsection{freeopcua}
%
%https://jaxenter.de/baukasten-fuer-das-internet-dinge-13532
%
%\subsection{REST}
%source: http://www.drdobbs.com/web-development/soa-web-services-and-restful-systems/199902676
%However, there exists an even less restrictive form of SOA than a web service—representational state transfer (REST). Described by Roy Fielding in his doctoral dissertation, REST is a collection of principals that are technology independent, except for the requirement that it be based on HTTP. A system that conforms to the following set of principals is said to be "RESTful":
%All components of the system communicate through interfaces with clearly defined methods and dynamic code.\\
%Each component is uniquely identified through a hypermedia link (URL).\\
%A client/server architecture is followed (web browser and web server).\\
%All communication is stateless.\\
%The architecture is tiered, and data can be cached at any layer.\\
%\\newline Overall, REST can be described as a technology and platform-independent architecture where loosely coupled components communicate via interfaces over standard web protocols. Software, hardware, and data-centric designs maximize system efficiency, scalability, and network throughput. The underlying principal is simplicity.
%Managing and evaluating the applications and provide privacy
%Supporting the decision-making process for the optimal investment and use of new telecommunications resources;
%b) Supporting the management of OA&M related budget;
%c) Supporting the supply and demand of OA&M related manpower; [5J
%d) Maintaining aggregate data about the total enterprise.
%
%\section{Middleware}
%A seemingly obvious solution, maybe from the experience of engineering in the “Internet” world, would be to simply enable the client and the server to be able to handle both the MQTT and CoAP protocols and depending on the remote device capabilities, to send the message in a suitable protocol. But in an environment where the processing and memory availability is highly constrained, implementing multiple protocols on these low- powered devices would not be an ideal situation. Implementing
%multi-protocol libraries and interoperability at the device level should be avoided. Hence, this leads to the need for IOT gateways or middlewares which can provide protocol level interoperability, by translating the data, context or the meaning of the message from one protocol to another protocol. In essence, the IOT gateway should be able to handle a situation where a message comes to a mobile device over the MQTT protocol and the same message, keeping the data (in case of sensing related information) or the command (in case of actuating related instructions) should be translated correctly to the CoAP protocol, without changing the meaning or context of the message.
%\section{Präsentation}
%Daten-Repräsentation und Applicationsdesign, verschiedene Zielsysteme (IOs, Android, Webapplikationen...)
%
\clearpage
%--------------------------------------------------------------KONZEPT & METHODE
\chapter{Angewandte Methoden}
Die Entwicklung des Systems erfolgte in vier Phasen der Entwicklung, die nicht strikt sequentiell sondern ineinander übergreifend und teilweise parallel bearbeitet wurden. Diese waren:
\begin{itemize}
	\item{Systemanalyse und Planung}
	\item{Auswahl der Komponenten durch Versuchsaufbauten}
	\item{Systementwurf}
	\item{Implementierung}
\end{itemize}
Die Ergebnisse der vorangegangenen Phasen wurden während der weiteren Systementwickung evaluiert und falls notwendig überarbeitet oder an neue Erfordernisse angepasst. In den nachfolgenden Abschnitten wird die Vorgehensweise zur Bearbeitung der einzelnen Stufen näher erläutert.
%
\section{Systemanalyse und Planung}
Um die Anforderungen an die Anwendung zu erfassen wurde eine Analyse der Systemgrenzen sowie der vorhandenen Hardware des Candy Grabbers vorgenommen. Aus diesen wurden die benötigten Ressourcen zur Versorgung des Systems sowie die erforderlichen Hardware-Eigenschaften ermittelt und eine Bestellliste erstellt. %Für die Versorgung der Motoren wurde anhand dieser Daten ein günstiges, einstellbares Netzteil ausgewählt, das bei 3-12V bis zu 600mA liefern kann.

%Analyse der Hardware, Festlegung der Systemgrenzen, Ableitung der benötigten Stromversorgung und Prüfung der möglichen Netzwerkanschlüsse, 
\subsection{Analyse der Hardware}
Zuerst wurde die Funktion des Candy Grabbers getestet und die notwendige Stromversorgung ermittelt. Da der Candy Grabber mit einem Batteriefach für drei C/LR14 Batterien á 1,5V ausgestattet war, wurde das System mit Spannungen von 3,3V, 4,5V und 5V über ein einstellbares Netzteil versorgt, dabei die Funktion der Motoren beobachtet sowie der Stromverbrauch gemessen. Der Stromverbrauch bewegte sich dabei bei gleichzeitiger Betätigung von zwei Motoren zwischen 120mA bei 3,3V bis 330 mA bei 5V. Alle Sensoren und Aktoren des Geräts waren funktionstüchtig. Anschließend wurde die Platine des Candy Grabbers ausgebaut und mit der Erfassung der Ein- und Ausgänge begonnen. Jedem erfassten Aktor oder Sensor wurde ein \ac{BMK} nach DIN EN 81346-2 zugeordnet, die für die Beschriftung der Verkabelung im Candy Grabber verwendet wurde. Die Tabellen \ref{tab:Is} und \ref{tab:Os} zeigen eine Auflistung aller Ein- und Ausgänge des Systems sowie deren BMK Nummern.
\begin{figure}[!htbp]
\centering
\includegraphics[width=0.55\textwidth]{PICs/Innenleben_des_candygrabbers_vorher.png}
\caption{Innenleben des Candy Grabbers}\label{fig:cgopen}
\end{figure}
%Tabelle Sensoren/ Aktoren liste
\begin{table}[H]
\centering
%\glqq / \grqq
\caption{Hardware Inputs des Candy Grabbers}\label{tab:Is}
\begin{tabular}{| p{0.08\linewidth} | p{0.27\linewidth} | p{0.4\linewidth} | p{0.15\linewidth} |}\hline
\rowcolor[gray]{0.8} BMK & Bauteil & Beschreibung & Raspberry Pi\\\hline
B1 & Lichtschranke RX & Receiver zeigt Gewinn an & GPIO 27\\
P1 & Lichtschranke TX & Emitterled &  \\\hline
B2 & Referenzschalter & Zeigt Münzeinwurf an & GPIO 16\\\hline
 & Schalter mit 3 Positionen & Zur Motorsteuerung (ON/OFF/ON) &\\
S1 & - & Greifer Links / Rechts & GPIO 24/25 \\
S2 & - & Greifer Vor / Zurück & GPIO 23/22\\
S3 & - & Greifer Hinauf / Hinunter & GPIO 5/6\\\hline
 & Grenztaster & Bei Erreichen einer Endstellung aktiv&\\
B3 & - &  Links & GPIO 18\\
B4 & - &  Rechts & GPIO 17 \\
B5 & - &  Vorne& GPIO 13\\
B6 & - &  Hinten& GPIO 12\\\hline
\end{tabular}
\end{table}
\begin{table}
\caption{Hardware Outputs des Candy Grabbers.}\label{tab:Os}
\begin{tabular}{| p{0.08\linewidth} | p{0.27\linewidth} | p{0.4\linewidth} | p{0.15\linewidth} |}\hline
\rowcolor[gray]{0.8} BMK & Bauteil & Beschreibung & \\\hline
P2 & Lautsprecher & Audioausgabe & Audio Out\\\hline
 & Motoren & Bewegen des Greifers& Motorhat\\
 M1 & - & Links / Rechts & M1\\
 M2 & - & Vor / Zurück & M2\\
 M3 & - & Greifer Hinauf / Hinunter & M3\\\hline
\end{tabular}
\end{table}
%
\subsection{Systemgrenzen}
Der Candy Grabber ist in einem Innenraum stationiert soll aber transportabel bleiben. Es stehen Router für einen Netzwerkanschluss über Ethernet zur Verfügung, die mit dem für Studierende freigegebenen \ac{LAN} der FH Technikum Wien verbunden sind. Im Raum sind mehrere Steckdosen platziert, die eine Stromversorgung über Netzteil ermöglichen. Es müssen keine maßgeblichen Temperaturgrenzen oder Einschränkungen des Datenvolumens- oder der Energieversorgung berücksichtigt werden. 
%
\subsection{Materialauswahl}
%Auswahl eines passenden IoT Devices und Erfassung der benötigten Teile für den Einkauf, Erstellung einer Bestellliste. Auswahl des Betriebssystems für das IoT Device und der verwendeten Programmiersprache, Aufsetzen des Geräts.
Auswahl eines IOT Geräts. Odroid, Raspberry Pi, Arduino. -> RPi gewählt. Überprüfung der Anzahl der benötigten GPIOs und Anschlüsse, sowie Rechenleistung des Geräts. Ausschlaggebender Auswahlgrund: gute Dokumentation zu Raspberry Pi vorhanden. Raspberry Pi: Verwendung von SD Card kann ein Risiko darstellen, Maßnahme: Regelmäßige Sicherung des RPi image zur Wiederherstellung im Notfall. Zusätzliches Zubehör: Gehäuse und Kühlkörper als Schutz für RPi. Die \ac{GPIO} Pins des Raspberry Pi sind sehr anfällig für Stromspitzen und arbeiten nur sicher in einem Bereich von 2mA-16mA. Daher sollten Motoren und Relais über externe Spannungsquellen versorgt werden. 
%
Auswahl der Steuerung der Motoren. Zur Auswahl: 1. H-Brücken für Richtungswechsel und PWM Signal für Geschwindigkeitsregelung oder 2. Verwendung eines passenden Motor-HATs. Da RPi nur 2 Hardware PWM Schnittstellen besitzt und drei Motoren angesteuert werden müssen wurde das HAT gewählt. Das DC \& Stepper Motor HAT von Adafruit {\color{red}Quelle link} bietet die Möglichkeit vier DC Motoren gleichzeitig zu anzusteuern. Ein \ac{PWM} Treiber Chip erlaubt die Regelung der Richtung sowie der Geschwindigkeit mittels \ac{PWM} über die \ac{I2C} Schnittstelle des Raspberry Pi. Für die Programmierung der Motoren bietet Adafruit eine eigene \ac{API} an. Zum Zweck der externen Versorgung der Motoren wurde anhand der oben gewonnenen Daten über den Verbrauch des Candy Grabbers ein günstiges, einstellbares Netzteil ausgewählt, das bei 3-12V bis zu 600mA liefern kann. Das Adafruit MotorHAT bietet eigene Klemmen für den Anschluss von Spannungsquellen von 6V bis. 
%
Auswahl einer Kamera für das Streaming. Webcams teurer als RPi Kamera, gute Dokumentation für RPi Kamera vorhanden. Fixed Fokus in RPi Kamera. Auswahl der RPi Cam v1.3: ausreichende Qualität bei geringerem Datenvolumen (5MP statt 8MP) und genügend Beleuchtungsmöglichkeit vorhanden. Erstellung der Bestellliste, Gesamtkosten unter 100 Euro. (Liste der bestellten Teile einfügen)
%Tabelle Bestellliste
\begin{table}[H]
\centering
%\glqq / \grqq
\caption{Bestellliste}
\label{tab:Order}
\begin{tabular}{| p{0.1\linewidth} | p{0.7\linewidth} | p{0.1\linewidth} |}\hline
\rowcolor[gray]{0.8} Anzahl & Bezeichnung & Preis\\\hline
	1 & RPi Kamera v1.3 5MP & \euro{ 20,91}\\\hline
	1 & Flex-Kabel 100cm für RPi Kamera & \euro{ 4,20}\\\hline
	1 & RPi Kamera Mount & \euro{ 5,00}\\\hline
	1 & Adafruit DC \& Stepper Motor HAT for RPi & \euro{ 34,00}\\\hline
	1 & RPi Gehäuse & \euro{ 6,00}\\\hline
	1 & Heatsink für RPi Aluminium & \euro{ 1,98}\\\hline
	1 & Netzteil für RPi (5V/2.5A) &\euro{ 6,00}\\\hline
	1 & Steckernetzteil für DC Motoren einstellbar 3-12V/600mA 7.2W & \euro{ 8,29}\\\hline
	Summe& & \cellcolor[gray]{0.9}\euro{86,38}\\\hline
\end{tabular}
\end{table}
%
\subsection{Sprachauswahl->Python}
{\color{blue}Python ist eine allgemeine Programmiersprache auf höherer Ebene. Es wurde entwickelt, um die Lesbarkeit von Code zu betonen, und es hält Sie vor allem davon ab, lose Zeiger zu haben
(ein Fluch aller C / C ++ - Programmierer) und erledigt die Speicherverwaltung für Sie. Dies ist die Programmiersprache der Wahl für den Raspberry Pi. Python verfügt über den größten Satz an Bibliotheken für IOT- und Embedded-System-Geräte jeder Sprache für den Raspberry Pi. One of the issues of Python is that of the memory garbage collector. Sometimes, your program will run out of memory and Python will invoke the garbage collector to clean up memory and set it up for reuse. This can cause your program to not execute in the time you expected.}
(<< aus Raspberry pi iot projects for makers)
Sprache gut geeignet für Prototyping
%
\section{Auswahl der Komponenten durch Experimente}
%Die einzelnen Komponenten wurden durch die zyklische Wiederholung von Recherche, (teilweiser) Implementierung und Evaluierung ausgewählt. Wurde eine Komponente ausgewählt und ausreichend getestet, konnte zur Auswahl der nächsten übergegangen werden. Vor jeder neuen Phase wurden Integrationstests durchgeführt.
Auswahl von Protokollen für Versuchsaufbauten. Durchführung der Versuchsaufbauten und Auswahl der verwendeten Schnittstellen und Schaltungen: Erstellung von Schaltungen, Teilweise Implementierung von kritischen Systemkomponenten wie Schnittstellen. Auswahlkriterien: Kompatibilität der Schnittstellen, Einfachheit der Bedienung / Implementierung, Qualität der Dokumentation, Kosten
\subsection{Hardwareanbindung, Schnittstellen}
Versuchsaufbauten zur Hardwareanbindung, Aufbau von Schaltungen am Breadboard und RPi Anbindung der Motoren sowie Sensoren. Zuweisung der Ein- und Ausgänge zu passenden, nicht für die I2C Kommunikation des MotorHATs notwendigen GPIOs des Raspberry Pi. Dokumentation.
%
\subsection{Kommunikation} 
Versuche für Kommunikation mit MQTT und OPC UA, es wurden weiters Versuchsaufbauten für die Applikation mit MIT App Inventor, Flask und Node-RED vorgenommen. Auswahl aus Versuchsaufbauten getroffen: Node-RED und OPC UA.
MIT App Inventor: einfach zu benutzen und Intuitiv, wie Node-RED ein flow-basiertes Programmiertool, jedoch kein WLAN Zugang im Raum vorhanden, Überlegung Bluetooth zu benutzen wurde wegen Datenvolumen des Videostreams und der geringen Reichweite verworfen. Entscheidung fiel daher auf Node-RED
%\section{Transport und Kommunikation}
\subsection{Node-red}
Hier wird der Aufbau von Node-RED genauer erläutert. Weiters werden Bilder der Flows der Versuchsaufbauten mit MQTT und OPC UA gezeigt, sowie der Anbindung des Raspberry PIs.
\subsubsection{MQTT Server mit Mosquitto}
Kurze Beschreibung des Versuchsaufbaus mit Bild von MQTT client Node.
\subsubsection{OPC UA Server mit python-opcua}
Der OPC UA Adressraum wird hier genauer erläutert und eine kurze Beschreibung des Versuchsaufbaus und der zwei betrachteten OPC UA Distributionen für Node-RED gegeben. Bilder der OPC UA Nodes für READ, WRITE und BROWSE.
%
%Als Schnittstellen zwischen dem Server und Clients dienen Services. Diese stellen vom Server angebotene Informationen dar die von Clients angefragt und genutzt werden können.
%
%\subsection{Flask}
%
\subsection{Kamera Live-Stream}
Versuche für Umsetzung des Videostreams mit MJPEG, VLC und RPi-Cam-Web-Interface (https://elinux.org/RPi-Cam-Web-Interface). RPi-Cam-Web-Interface hatte am wenigsten Delay. Für die grafische Benutzeroberfläche wurde das dashboard von Node-RED verwendet.

\begin{verbatim}
	$ raspivid -o - -t 0 -hf -w 800 -h 400 -fps 24 | cvlc -vvv stream:///dev/stdin \ 
	—sout ‘#standard{access=http,mux=ts,dst=:8160}’ :demux=h264
\end{verbatim}
im vlc player kann über media/network auf den Stream zugegriffen werden. auch sehr hohe latenz (2,5 sec).
%\subsubsection{Mjpeg}
%\subsubsection{Vidstream und VLC}
%\subsubsection{Linux Raspberry Pi Web Cam Interface}
%
\subsection{Applikationsdesign}
Versuche mit dem Node-RED Dashboard
%\subsubsection{MIT App Inventer}
%\subsubsection{Node-red dashboard}
%
\clearpage
\section{Systementwurf}
Nach abgeschlossener Auswahl der Systemkomponenten wurde die Software mit UML modelliert. UML ist eine Modellierungssprache zur Softwareentwicklung. (Kurze Beschreibung und Quelle). Hierfür wurde ein Klassendiagramm erstellt indem die statischen Beziehungen zwischen den einzelnen Klassen der Software dargestellt werden. Weiters wurde ein Ablaufdiagramm erstellt sowie ein Zustandsautomat (state machine) entworfen. Anhand dieser Modelle wurde die Systemimplementierung in Python vorgenommen.
%
\subsection{Systemmodellierung}
Hier werden die UML Diagramme erläutert und die Softwarestruktur des Candy Grabbers genauer betrachtet.
\begin{figure}[!htbp]
\centering
\includegraphics[width=0.8\linewidth]{/Users/Makki/Documents/candy-grabber/StateMachine.png}
\caption{State machine des Candy Grabbers}
\end{figure}
%
%
\begin{figure}[!htbp]
\centering
\includegraphics[width=\linewidth]{/Users/Makki/Documents/candy-grabber/ClassDiagram_CG.png}
\caption{UML Klassendiagramm des \emph{CandyGrabber} Objekts}
\end{figure}
%
\subsection{Softwarekomponenten und Libraries}
Verwendete Libraries und Node-RED Frameworks. Genaue Beschreibung der Klassen des Candy Grabbers.
%
\subsection{HMI Entwurf}
Benötigte Taster, Schalter, Informationen und Layout
%--------------------------------------------------------------UMSETZUNG
%\chapter{Umsetzung}
\section{Implementierung}
Zusammenführen der einzelnen Komponenten, Modifizierung der vorhandenen Hardware sowie Montage und Verbindung der Hardwaremodule. Erstellung der Programmierung. Während der Implementierung der Software wurde der Entwurf evaluiert und iterativ überarbeitet. Diese Änderungen wurden wiederum in die UML Diagramme übernommen um immer ein aktuelles Bild vom Stand des Systems zu erhalten. Versionen der UML Diagramme wurden ebenso wie die Versionierung der Software über ein GIT Repository organisiert.
%
\subsection{Modifizierung der Hardware und Montage}
\begin{figure}[H]%
        		\begin{minipage}[t]{\linewidth}%
          	%\begin{center}%
			\begin{minipage}{0.5\linewidth}
				\begin{center}%
           				\includegraphics[width=0.9\linewidth]{./PICs/verkabelung_motoren_vorher.png}%
				\end{center}%
			\end{minipage}
			\begin{minipage}{0.5\linewidth}
				\begin{center}
           				\includegraphics[width=0.9\linewidth]{./PICs/verkabelung_motoren_nachher.png}%
				\end{center}%
			\end{minipage}
			\caption{Verkabelung der Grenztaster und Motoren der x- und y-Achse vor und nach den vorgenommenen Modifizierungen}%
			\label{fig:HWmodified}%
          	%\end{center}%
        		\end{minipage}%PackMLsimple copy
\end{figure}%
%
\subsection{Programmierung}
Node-RED Flow Erstellung sowie Implementierung eigener Nodes in Java Script.
Erstellung der Klassen, Hardware Abstraktion und Erstellung des Python Programms für manuelle Bedienung. Repräsentation des Python Objekts im OPC UA Adressraum. Programmierung des Ablaufs für Remote Bedienung über Server und Node-RED Flow.
\begin{lstlisting}[language=Python,name={2. Beispiel},label={sc:bsp:2}]
#include <iostream>

void SayHello(void)
{
    // Kommentar
    cout << "Hello World!" << endl;
}

int main(int argc, char **argv)
{
    SayHello();
    return 0;
}
\end{lstlisting}
\subsection{Versionierung und Dokumentation}
Erstellung eines Git Repositories. Lesbarkeit des Codes und Einfügen von Kommentaren.
\subsection{Systemintegration und Tests}
Hardwareentwurf und Einbau aller Komponenten in den Candy Grabber. Beschriftung der Kabelverbindungen und Klemmen an der Hardware. Durchführung von Software-tests und Code-Hygiene (Debugging und Kommentare). Durchführung von Funktionstests.
%
\clearpage
\chapter{Ergebnisse}
Hier werden die Ergebnisse präsentiert. Ansichten der Umsetzung (Hardware, HMI).
\begin{table}[!htbp]
\caption{Umgesetzte Arbeitspakete}
\centering
\begin{tabular}{| p{0.33\linewidth}| p{0.33\linewidth} | p{0.33\linewidth}|}\hline
\rowcolor[gray]{0.8}Analyse und Planung & &\\\hline
Auswahl eines \ac{IOT} Geräts & Auswahl zusätzlich benötigter Hardware & Gründliche Dokumentation\\\hline
Analyse der Original Hardware & Erstellung Sensor/Aktor Liste \newline Entwurf Schaltplan & Anschluss an Rechner\\\hline
\rowcolor[gray]{0.8}Systementwurf &&\\\hline
Hardware Abstraktion und Schnittstellen & Systementwurf \newline Klassendiagramm erstellen & Ablauf planen \newline Ablaufdiagramm erstellen\\\hline
Schnittstellen und Systemgrenzen definieren & Methoden und Properties \newline definieren & Steuerungsprogramm erstellen\\\hline
\rowcolor[gray]{0.8}Systementwicklung &&\\\hline
Versuchsaufbauten erstellen & Auswahl der Toolchain &  Aufsetzen eines Servers \\\hline
Kommunikation mit Client & Webapplikation erstellen & Videostream einrichten\\\hline
\end{tabular}
\end{table}
%
\clearpage
\chapter{Zusammenfassung und Ausblick}
Evaluierung der Ergebnisse durch Vergleich mit den Anforderungen. Was wurde nicht implementiert und warum. Was sind die nächsten Schritte, wie könnte das System noch verbessert werden.
% Hier beginnen die Verzeichnisse.
%

%----------------------------------ZIELE
\section{Projektziele}
%Recherche zu \ac{IOT} und Rapid-Prototyping im \ac{IOT} Bereich. Erstellen einer Übersicht von Tools die speziell für Prototyping entwickelt wurden. Gegenüberstellung und Diskussion der Vor- und Nachteile der vorgestellten Modelle und Methoden für die Anwendung in dieser Arbeit. Recherche über:
%\begin{itemize}
%	\item \ac{IOT} Architektur, Schichtmodelle
%	%\item Schnittstellen
%	\item Protokolle
%	\item Softwareplattformen
%	\item \ac{IOT} Geräte (\ac{IOT} devices)
%\end{itemize}
%Auswahl der Toolchain und Erstellen der \ac{IOT} Applikation für den Candy Grabber:
%\begin{itemize}
%	\item Hardware Auswahl
%	\item Hardware über GPIOs steuerbar, Motoren über Motorsteuerung (H-Brücken / Motor-Modul) steuerbar.
%	\item Umsetzung der Transportschicht, Versenden/Austauschen von Datenpaketen.
%	\item Erstellung einer Anwendung und Bereitstellung im Internet (Webdienst bereitstellen)
%\end{itemize}
Bewertung der Umsetzung nach folgenden Qualitätskriterien:
\begin{itemize}
	\item Simplizität
	\item Kosten
	\item Skalierbarkeit
	%\item Energieverbrauch
	\item Modularität
	\item Nachvollziehbarkeit
\end{itemize}
%----------------------------------------------------ZUSAMMENFASSUNG

%\rowcolor[gray]{0.8}Systemintegration &&\\\hline
%\section{Meilensteine}
%{\color{red}Zum Zwecke der Messbarkeit, hier noch eine zeitliche Einteilung als Richtlinie zur Umsetzung des Projekts:}
%%Tabelle Meilensteine
\begin{table}[!htbp]
\caption{Diese Tabelle dient zur Überprüfung des Projektfortschritts und ist kein Bestandteil der schriftlichen Arbeit}
\centering
\begin{tabular}{| p{0.8\linewidth}| p{0.2\linewidth} |}\hline
Meilensteine & Zeitplan\\\hline
Aufsetzen des IoT Device (Raspberry Pi) &\cellcolor{green} Anfang März\\
Formulieren der Ziele & \cellcolor{green} 08.März\\
(zusätzliche) Hardware Auswahl und Abgabe Bestellliste &\cellcolor{green} 16.März\\
Hardware steuerbar über Rechner & \cellcolor{yellow} 30.März\\
Recherche zum Stand der Technik & \cellcolor{yellow} 14.April\\
Auswahl und Installation der Toolchain & \cellcolor{green} 30.April\\
Implementierung der IoT Anwendung & \cellcolor{green} 30.Mai\\
Präsentation des Candy Grabbers, Erstellung eines Videos & 13.Juni\\
Bewertung der Umsetzung und Fertigstellung der BA Arbeit & 16.Juni\\\hline
\end{tabular}
\end{table}
\clearpage
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{}{\bibliographystyle{gerabbrv}}
\bibliography{Literatur}
\clearpage

% Das Abbildungsverzeichnis
\listoffigures
\clearpage

% Das Tabellenverzeichnis
\listoftables
\clearpage

% Das Quellcodeverzeichnis
\listofcode
\clearpage

\phantomsection
\addcontentsline{toc}{chapter}{\listacroname}
\chapter*{\listacroname}
\begin{acronym}[XXXXX]
	\acro{API}[API]{Application Programming Interface}
	\acro{BMK}[BMK]{Betriebsmittelkennzeichen}
	\acro{CIOT}[CIoT]{Commercial Internet of Things}
	\acro{CoAP}[CoAP]{Constrained Application Protocol}
	\acro{ETSI}[ETSI]{European Telecommunications Standards Institute}
	\acro{GPIO}[GPIO]{General Purpose Input/Output}
	\acro{HMI}[HMI]{Human Machine Interface}
	\acro{HTTP}[HTTP]{Hypertext Transfer Protocol}
	\acro{IETF}{IETF}{Internet Engineering Task Force}
	\acro{IEEE}[IEEE]{Institute of Electrical and Electronics Engineers}
	\acro{I2C}[I2C]{Inter-Integrated Circuit}
	\acro{IIOT}[IIoT]{Industrial Internet of Things}
	\acro{IOT}[IoT]{Internet of Things}
	\acro{LAN}[LAN]{Local Area Network}
   	\acro{MQTT}[MQTT]{Message Queuing Telemetry Transport}
	\acro{OPC UA}[OPC UA]{OPC Unified Architecture}
   	\acro{OSI}[OSI]{Open Systems Interconnection}
	\acro{PWM}[PWM]{Pulsweitenmodulation}
	\acro{REST}[REST]{Representational State Transfer}
   	\acro{SOA}[SOA]{Service-Oriented Architecture}
	\acro{SOAP}[SOAP]{Simple Object Access Protocol}
   	\acro{TCP}[TCP/IP]{Transmission Control Protocol/Internet Protocol}
	\acro{UDP}[UDP]{User Datagram Protocol}
	\acro{W3C}[W3C]{World Wide Web Consortium}
   	\acro{WWW}[WWW]{World Wide Web}
   	\acro{WSN}[WSN]{Wired Sensor Network}
\end{acronym}

%
% Hier beginnt der Anhang.
%
\clearpage
\appendix
\chapter{Anhang A}
\clearpage
\chapter{Anhang B}
\end{document}

%\noindent Querverweise werden in \LaTeX{} automatisch erzeugt und verwaltet, damit sie leicht aktualisiert werden können. Hier wird zum Beispiel auf Abbildung \ref{Abb1} verwiesen.
%
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=0.5\linewidth]{PICs/buchruecken}
%\caption{Beispiel für die Beschriftung eines Buchrückens.}\label{Abb1}
%\end{figure}
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=0.5\linewidth]{PICs/buchruecken}
%\caption{2. Beispiel für die Beschriftung eines Buchrückens.}\label{Abb2}
%\end{figure}
%
%Und hier ist ein Verweis auf Tabelle \ref{tab1}. Das gezeigte Tabellenformat ist nur ein Beispiel. Tabellen können individuell gestaltet werden.
%
%\begin{table}[!htbp]
%\centering
%\caption{Semesterplan der Lehrveranstaltung \glqq Angewandte Mathematik\grqq.}\label{tab1}
%\begin{tabular}{| p{0.3\linewidth} | p{0.3\linewidth} | p{0.3\linewidth} |}\hline
%Datum & Thema & Raum\\\hline
%20.08.2008 & Graphentheorie & HS 3.13\\
%01.10.2008 & Biomathematik & HS 1.05\\\hline
%\end{tabular}
%\end{table}
%\begin{table}[!htbp]
%\centering
%\caption{2. Semesterplan der Lehrveranstaltung \glqq Angewandte Mathematik\grqq.}\label{tab2}
%\begin{tabular}{| p{0.3\linewidth} | p{0.3\linewidth} | p{0.3\linewidth} |}\hline
%Datum & Thema & Raum\\\hline
%20.08.2008 & Graphentheorie & HS 3.13\\
%01.10.2008 & Biomathematik & HS 1.05\\\hline
%\end{tabular}
%\end{table}
%
%Hier wird auf die Formel \ref{Gl1} verwiesen.
%
%\begin{align}
%x = -\frac{p}{2}\pm\sqrt{\frac{p^2}{4}-q}\label{Gl1}
%\end{align}
%\begin{align}
%x = -\frac{p}{2}\pm\sqrt{\frac{p^2}{4}-q}\label{Gl2}
%\end{align}
%
%\begin{lstlisting}[language=C++,name={1. Beispiel},label={sc:bsp:1}]
%#include <iostream>
%
%void SayHello(void)
%{
%    // Kommentar
%    cout << "Hello World!" << endl;
%}
%
%int main(int argc, char **argv)
%{
%    SayHello();
%    return 0;
%}
%\end{lstlisting}
%
%Literaturverweise sollten automatisch verwaltet werden, vor allem, wenn es viele Quellenverweise gibt. Beispiele sind  \cite{Ko05a}, \cite{Ko05b}, \cite{MiGo05}, \cite{TeGo14}, \cite{HuHa07}, \cite{HuZi10}, \cite{ZiKu07}, \cite{He07}, \cite{SIE11}, \cite{SIE14}, \cite{ISO98}, \cite{ATM11}, \cite{Hu11}, \cite{Po10}. Das verwendete Zitierformat (bzw.~das Format des Literaturverzeichnisses) ist entspechend der Vorgaben der Studiengänge zu wählen.
%Es wird dringend empfohlen, BibTeX~zu verwenden (wie in diesem Beispiel).
%
%\chapter{Dritte Überschrift der Tiefe 1 (chapter)}
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=0.5\linewidth]{PICs/buchruecken}
%\caption{3. Beispiel für die Beschriftung eines Buchrückens.}\label{Abb3}
%\end{figure}
%\begin{figure}[!htbp]
%\centering
%\includegraphics[width=0.5\linewidth]{PICs/buchruecken}
%\caption{4. Beispiel für die Beschriftung eines Buchrückens.}\label{Abb4}
%\end{figure}
%
%
%\begin{table}[!htbp]
%\centering
%\caption{3. Semesterplan der Lehrveranstaltung \glqq Angewandte Mathematik\grqq.}\label{tab3}
%\begin{tabular}{| p{0.3\linewidth} | p{0.3\linewidth} | p{0.3\linewidth} |}\hline
%Datum & Thema & Raum\\\hline
%20.08.2008 & Graphentheorie & HS 3.13\\
%01.10.2008 & Biomathematik & HS 1.05\\\hline
%\end{tabular}
%\end{table}
%\begin{table}[!htbp]
%\centering
%\caption{4. Semesterplan der Lehrveranstaltung \glqq Angewandte Mathematik\grqq.}\label{tab4}
%\begin{tabular}{| p{0.3\linewidth} | p{0.3\linewidth} | p{0.3\linewidth} |}\hline
%Datum & Thema & Raum\\\hline
%20.08.2008 & Graphentheorie & HS 3.13\\
%01.10.2008 & Biomathematik & HS 1.05\\\hline
%\end{tabular}
%\end{table}
%
%\begin{align}
%x = -\frac{p}{2}\pm\sqrt{\frac{p^2}{4}-q}\label{Gl3}
%\end{align}
%\begin{align}
%x = -\frac{p}{2}\pm\sqrt{\frac{p^2}{4}-q}\label{Gl4}
%\end{align}
%\begin{lstlisting}[language=C++,name={2. Beispiel},label={sc:bsp:2}]
%#include <iostream>
%
%void SayHello(void)
%{
%    // Kommentar
%    cout << "Hello World!" << endl;
%}
%
%int main(int argc, char **argv)
%{
%    SayHello();
%    return 0;
%}
%\end{lstlisting}
